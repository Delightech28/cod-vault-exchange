// This file is automatically generated. Do not edit it directly.



// Lightweight adapter that replaces Supabase client with HTTP API calls
const API_URL = (import.meta.env.VITE_API_URL as string) || 'http://localhost:4000';
import { io as ioClient, Socket } from 'socket.io-client';

// Singleton socket instance
let socket: Socket | null = null;
function getSocket() {
  if (!socket) {
    try {
      socket = ioClient(API_URL);
      socket.on('connect', () => console.log('socket connected', socket?.id));
      socket.on('connect_error', (err) => console.warn('socket connect_error', err));
    } catch (e) {
      console.warn('socket.io init error', e);
      socket = null;
    }
  }
  return socket;
}

function makeBuilder(collection: string) {
  const filters: Record<string, any> = {};
  let _limit: number | null = null;
  let _single = false;
  let _orderField: string | null = null;
  let _orderAsc = true;

  const builder: any = {
    select: (_sel?: string) => builder,
    eq: (field: string, val: any) => { filters[field] = val; return builder; },
    order: (field: string, opts?: { ascending?: boolean }) => { _orderField = field; _orderAsc = opts?.ascending ?? true; return builder; },
    limit: (n: number) => { _limit = n; return builder; },
    single: () => { _single = true; return builder.execute(); },
    execute: async () => {
      const params = new URLSearchParams();
      Object.entries(filters).forEach(([k, v]) => params.append(k, String(v)));
      if (_limit) params.set('limit', String(_limit));
      if (_orderField) { params.set('sort', _orderField); params.set('order', _orderAsc ? 'asc' : 'desc'); }
      const url = `${API_URL}/api/${collection}?${params.toString()}`;
      const res = await fetch(url);
      const json = await res.json();
      let data = json.data ?? json;
      if (_orderField) {
        data = data.sort((a: any, b: any) => {
          if (a[_orderField] < b[_orderField]) return _orderAsc ? -1 : 1;
          if (a[_orderField] > b[_orderField]) return _orderAsc ? 1 : -1;
          return 0;
        });
      }
      if (_limit) data = data.slice(0, _limit);
      if (_single) data = data[0] ?? null;
      return { data };
    }
  };

  (builder as any).then = async (onfulfilled: any, onrejected: any) => {
    try { const res = await builder.execute(); return onfulfilled ? onfulfilled(res) : res; }
    catch (e) { if (onrejected) return onrejected(e); throw e; }
  };

  return builder;
}

export const supabase = {
  auth: {
    getUser: async () => {
      const token = localStorage.getItem('auth_token');
      const res = await fetch(`${API_URL}/auth/user`, { headers: token ? { Authorization: `Bearer ${token}` } : {} });
      const json = await res.json();
      return { data: { user: json.user ?? null } };
    },
    getSession: async () => {
      const token = localStorage.getItem('auth_token');
      if (!token) return { data: { session: null } };
      try {
        const res = await fetch(`${API_URL}/auth/user`, { headers: { Authorization: `Bearer ${token}` } });
        const json = await res.json();
        return { data: { session: { user: json.user ?? null, access_token: token } } };
      } catch (e) {
        return { data: { session: null } };
      }
    },
    login: async ({ email, name }: { email: string, name?: string }) => {
      const res = await fetch(`${API_URL}/auth/login`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, name }) });
      const json = await res.json();
      if (json.token) localStorage.setItem('auth_token', json.token);
      // notify other parts of the app
      try { window.dispatchEvent(new Event('supabase-login')); } catch(e){}
      return { data: { user: json.user, token: json.token } };
    },
    signOut: async () => {
      localStorage.removeItem('auth_token');
      try { window.dispatchEvent(new Event('supabase-logout')); } catch(e){}
      return { error: null };
    },
    onAuthStateChange: (callback: (event: string, session: any) => void) => {
      const handler = async () => {
        const token = localStorage.getItem('auth_token');
        let user = null;
        if (token) {
          try {
            const res = await fetch(`${API_URL}/auth/user`, { headers: { Authorization: `Bearer ${token}` } });
            const json = await res.json();
            user = json.user ?? null;
          } catch (e) {
            user = null;
          }
        }
        const session = user ? { access_token: token, user } : null;
        callback(user ? 'SIGNED_IN' : 'SIGNED_OUT', session);
      };

      const storageListener = (e: StorageEvent) => {
        if (e.key === 'auth_token') handler();
      };
      window.addEventListener('storage', storageListener);
      const loginListener = () => handler();
      window.addEventListener('supabase-login', loginListener as EventListener);
      const logoutListener = () => handler();
      window.addEventListener('supabase-logout', logoutListener as EventListener);

      return { data: { subscription: { unsubscribe: () => {
        window.removeEventListener('storage', storageListener);
        window.removeEventListener('supabase-login', loginListener as EventListener);
        window.removeEventListener('supabase-logout', logoutListener as EventListener);
      } } } };
    }
  },
  from: (collection: string) => makeBuilder(collection),
  functions: {
    invoke: async (name: string, opts?: any) => {
      const token = localStorage.getItem('auth_token');
      const res = await fetch(`${API_URL}/functions/${name}`, { method: 'POST', headers: { 'Content-Type': 'application/json', ...(token ? { Authorization: `Bearer ${token}` } : {}) }, body: JSON.stringify(opts?.body ?? {}) });
      const json = await res.json();
      return { data: json };
    }
  },
  // Minimal storage stub to avoid runtime errors; implement server endpoints if needed.
  storage: {
    from: (bucket: string) => ({
      upload: async (path: string, file: any, _opts?: any) => {
        try {
          const form = new FormData();
          // `file` may be a File/Blob or a string (base64) depending on callers
          if (typeof File !== 'undefined' && file instanceof File) {
            form.append('file', file, file.name || 'file');
          } else if (file && file.buffer) {
            // node-style buffer (unlikely in browser)
            form.append('file', new Blob([file.buffer]), file.originalname || 'file');
          } else if (file instanceof Blob) {
            form.append('file', file, 'file');
          } else {
            // try to convert string
            const blob = new Blob([String(file || '')]);
            form.append('file', blob, 'file');
          }
          form.append('bucket', bucket);
          form.append('path', path);
          const res = await fetch(`${API_URL}/storage/upload`, { method: 'POST', body: form });
          const json = await res.json();
          if (json.error) return { data: null, error: json };
          return { data: json.data };
        } catch (err: any) {
          return { data: null, error: { message: err?.message || String(err) } };
        }
      },
      getPublicUrl: async (path: string) => {
        try {
          const params = new URLSearchParams({ bucket, path });
          const res = await fetch(`${API_URL}/storage/publicUrl?${params.toString()}`);
          const json = await res.json();
          return { data: json.data };
        } catch (err: any) {
          return { data: null, error: { message: err?.message || String(err) } };
        }
      },
      createSignedUrl: async (path: string, opts?: any) => {
        try {
          const params = new URLSearchParams({ bucket, path });
          if (opts?.expires) params.set('expires', String(opts.expires));
          const res = await fetch(`${API_URL}/storage/signedUrl?${params.toString()}`);
          const json = await res.json();
          return { data: json.data };
        } catch (err: any) {
          return { data: null, error: { message: err?.message || String(err) } };
        }
      }
    })
  },
  channel: (name: string) => {
    const socket = getSocket();
    const listeners: Array<{ eventName: string, handler: (...args:any[]) => void }> = [];
    const ch = {
      name,
      on: (_eventType: string, opts: any, handler: (...args:any[]) => void) => {
        // support Supabase 'postgres_changes' event shape: { event, schema, table }
        if (_eventType === 'postgres_changes' && opts && opts.table) {
          const events = opts.event === '*' ? ['INSERT', 'UPDATE', 'DELETE'] : [opts.event];
          events.forEach((evt: string) => {
            const eventName = `${opts.table}:${evt}`;
            const fn = (...args:any[]) => handler(...args);
            listeners.push({ eventName, handler: fn });
            try { socket?.on(eventName, fn); } catch(e){}
          });
        }
        return ch;
      },
      subscribe: async () => ({ status: 'SUBSCRIBED' }),
      unsubscribe: () => {
        listeners.forEach(({ eventName, handler }) => {
          try { socket?.off(eventName, handler); } catch(e){}
        });
        listeners.length = 0;
      }
    } as any;
    return ch;
  },
  removeChannel: (ch: any) => { try { ch?.unsubscribe?.(); } catch(e){} },
  rpc: async (path: string, body?: any) => {
    const token = localStorage.getItem('auth_token');
    const res = await fetch(`${API_URL}/${path}`, { method: body ? 'POST' : 'GET', headers: { 'Content-Type': 'application/json', ...(token ? { Authorization: `Bearer ${token}` } : {}) }, body: body ? JSON.stringify(body) : undefined });
    return res.json();
  }
} as any;