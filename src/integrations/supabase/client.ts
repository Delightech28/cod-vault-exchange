// This file is automatically generated. Do not edit it directly.



// Lightweight adapter that replaces Supabase client with HTTP API calls
const API_URL = (import.meta.env.VITE_API_URL as string) || 'http://localhost:4000';
import { io as ioClient, Socket } from 'socket.io-client';

// Singleton socket instance
let socket: Socket | null = null;
function getSocket() {
  if (!socket) {
    try {
      socket = ioClient(API_URL);
      socket.on('connect', () => console.log('socket connected', socket?.id));
      socket.on('connect_error', (err) => console.warn('socket connect_error', err));
    } catch (e) {
      console.warn('socket.io init error', e);
      socket = null;
    }
  }
  return socket;
}

function makeBuilder(collection: string) {
  const filters: Record<string, any> = {};
  let _limit: number | null = null;
  let _single = false;
  let _orderField: string | null = null;
  let _orderAsc = true;
  let _id: string | null = null;
  let _method: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'GET';
  let _body: any = null;

  const builder: any = {
    select: (_sel?: string) => { _method = 'GET'; return builder; },
    eq: (field: string, val: any) => {
      if (field === 'id') {
        _id = String(val);
      } else if (field === 'user_id' && collection === 'profiles') {
        // Special case for profiles to treat user_id as lookup key if id not provided
        _id = String(val);
      } else {
        filters[field] = val;
      }
      return builder;
    },
    order: (field: string, opts?: { ascending?: boolean }) => { _orderField = field; _orderAsc = opts?.ascending ?? true; return builder; },
    limit: (n: number) => { _limit = n; return builder; },
    single: () => { _single = true; return builder; },
    maybeSingle: () => { _single = true; return builder; },
    update: (data: any) => {
      _method = 'PUT';
      _body = data;
      return builder;
    },
    delete: () => {
      _method = 'DELETE';
      return builder;
    },
    insert: (data: any) => {
      _method = 'POST';
      _body = data;
      return builder;
    },
    execute: async () => {
      const token = localStorage.getItem('auth_token');
      const headers: Record<string, string> = { 'Content-Type': 'application/json' };
      if (token) headers['Authorization'] = `Bearer ${token}`;

      if (_method === 'GET') {
        const params = new URLSearchParams();
        Object.entries(filters).forEach(([k, v]) => params.append(k, String(v)));
        if (_limit) params.set('limit', String(_limit));
        if (_orderField) { params.set('sort', _orderField); params.set('order', _orderAsc ? 'asc' : 'desc'); }

        const url = _id
          ? `${API_URL}/api/${collection}/${_id}`
          : `${API_URL}/api/${collection}?${params.toString()}`;

        const res = await fetch(url, { headers });
        const json = await res.json();
        let data = json.data ?? json;

        if (Array.isArray(data)) {
          if (_orderField) {
            data = data.sort((a: any, b: any) => {
              if (a[_orderField] < b[_orderField]) return _orderAsc ? -1 : 1;
              if (a[_orderField] > b[_orderField]) return _orderAsc ? 1 : -1;
              return 0;
            });
          }
          if (_limit) data = data.slice(0, _limit);
          if (_single) data = data[0] ?? null;
        }
        return { data, error: json.error ? { message: json.error } : null };
      } else if (_method === 'PUT') {
        const targetId = _id || filters.id;
        if (!targetId) return { data: null, error: { message: 'Update requires an ID. Use .eq("id", value) or .eq("user_id", value) for profiles.' } };

        const res = await fetch(`${API_URL}/api/${collection}/${targetId}`, {
          method: 'PUT',
          headers,
          body: JSON.stringify(_body)
        });
        const json = await res.json();
        return { data: json.data, error: json.error ? { message: json.error } : null };
      } else if (_method === 'DELETE') {
        const targetId = _id || filters.id;
        if (!targetId) return { data: null, error: { message: 'Delete requires an ID' } };

        const res = await fetch(`${API_URL}/api/${collection}/${targetId}`, {
          method: 'DELETE',
          headers
        });
        const json = await res.json();
        return { data: json, error: json.error ? { message: json.error } : null };
      } else if (_method === 'POST') {
        const res = await fetch(`${API_URL}/api/${collection}`, {
          method: 'POST',
          headers,
          body: JSON.stringify(_body)
        });
        const json = await res.json();
        return { data: json.data, error: json.error ? { message: json.error } : null };
      }
      return { data: null, error: { message: 'Unsupported method' } };
    }
  };

  (builder as any).then = async (onfulfilled: any, onrejected: any) => {
    try {
      const res = await builder.execute();
      return onfulfilled ? onfulfilled(res) : res;
    } catch (e) {
      if (onrejected) return onrejected(e);
      throw e;
    }
  };

  return builder;
}

export const supabase = {
  auth: {
    getUser: async () => {
      const token = localStorage.getItem('auth_token');
      const res = await fetch(`${API_URL}/auth/user`, { headers: token ? { Authorization: `Bearer ${token}` } : {} });
      const json = await res.json();
      return { data: { user: json.user ?? null } };
    },
    getSession: async () => {
      const token = localStorage.getItem('auth_token');
      if (!token) return { data: { session: null } };
      try {
        const res = await fetch(`${API_URL}/auth/user`, { headers: { Authorization: `Bearer ${token}` } });
        if (!res.ok) return { data: { session: null } };
        const json = await res.json();
        return { data: { session: { user: json.user ?? null, access_token: token } } };
      } catch (e) {
        return { data: { session: null } };
      }
    },
    signUp: async ({ email, password, name }: { email: string, password?: string, name?: string }) => {
      try {
        const res = await fetch(`${API_URL}/auth/signup`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password, name })
        });
        const json = await res.json();
        if (!res.ok) {
          return { data: { user: null, token: null }, error: { message: json.error || 'Sign up failed' } };
        }
        if (json.token) localStorage.setItem('auth_token', json.token);
        try { window.dispatchEvent(new Event('supabase-login')); } catch (e) { }
        return { data: { user: json.user, token: json.token }, error: null };
      } catch (err: any) {
        return { data: { user: null, token: null }, error: { message: err.message || 'Network error during signup' } };
      }
    },
    login: async ({ email, password }: { email: string, password?: string }) => {
      try {
        const res = await fetch(`${API_URL}/auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password })
        });
        const json = await res.json();
        if (!res.ok) {
          return { data: { user: null, token: null }, error: { message: json.error || 'Login failed' } };
        }
        if (json.token) localStorage.setItem('auth_token', json.token);
        // notify other parts of the app
        try { window.dispatchEvent(new Event('supabase-login')); } catch (e) { }
        return { data: { user: json.user, token: json.token }, error: null };
      } catch (err: any) {
        return { data: { user: null, token: null }, error: { message: err.message || 'Network error during login' } };
      }
    },
    signOut: async () => {
      localStorage.removeItem('auth_token');
      try { window.dispatchEvent(new Event('supabase-logout')); } catch (e) { }
      return { error: null };
    },
    onAuthStateChange: (callback: (event: string, session: any) => void) => {
      const handler = async () => {
        const token = localStorage.getItem('auth_token');
        let user = null;
        if (token) {
          try {
            const res = await fetch(`${API_URL}/auth/user`, { headers: { Authorization: `Bearer ${token}` } });
            const json = await res.json();
            user = json.user ?? null;
          } catch (e) {
            user = null;
          }
        }
        const session = user ? { access_token: token, user } : null;
        callback(user ? 'SIGNED_IN' : 'SIGNED_OUT', session);
      };

      const storageListener = (e: StorageEvent) => {
        if (e.key === 'auth_token') handler();
      };
      window.addEventListener('storage', storageListener);
      const loginListener = () => handler();
      window.addEventListener('supabase-login', loginListener as EventListener);
      const logoutListener = () => handler();
      window.addEventListener('supabase-logout', logoutListener as EventListener);

      return {
        data: {
          subscription: {
            unsubscribe: () => {
              window.removeEventListener('storage', storageListener);
              window.removeEventListener('supabase-login', loginListener as EventListener);
              window.removeEventListener('supabase-logout', logoutListener as EventListener);
            }
          }
        }
      };
    }
  },
  from: (collection: string) => makeBuilder(collection),
  functions: {
    invoke: async (name: string, opts?: any) => {
      const token = localStorage.getItem('auth_token');
      const res = await fetch(`${API_URL}/functions/${name}`, { method: 'POST', headers: { 'Content-Type': 'application/json', ...(token ? { Authorization: `Bearer ${token}` } : {}) }, body: JSON.stringify(opts?.body ?? {}) });
      const json = await res.json();
      return { data: json };
    }
  },
  // Minimal storage stub to avoid runtime errors; implement server endpoints if needed.
  storage: {
    from: (bucket: string) => ({
      upload: async (path: string, file: any, _opts?: any) => {
        try {
          const form = new FormData();
          // `file` may be a File/Blob or a string (base64) depending on callers
          if (typeof File !== 'undefined' && file instanceof File) {
            form.append('file', file, file.name || 'file');
          } else if (file && file.buffer) {
            // node-style buffer (unlikely in browser)
            form.append('file', new Blob([file.buffer]), file.originalname || 'file');
          } else if (file instanceof Blob) {
            form.append('file', file, 'file');
          } else {
            // try to convert string
            const blob = new Blob([String(file || '')]);
            form.append('file', blob, 'file');
          }
          form.append('bucket', bucket);
          form.append('path', path);
          const res = await fetch(`${API_URL}/storage/upload`, { method: 'POST', body: form });
          const json = await res.json();
          if (json.error) return { data: null, error: json };
          return { data: json.data };
        } catch (err: any) {
          return { data: null, error: { message: err?.message || String(err) } };
        }
      },
      getPublicUrl: async (path: string) => {
        try {
          const params = new URLSearchParams({ bucket, path });
          const res = await fetch(`${API_URL}/storage/publicUrl?${params.toString()}`);
          const json = await res.json();
          return { data: json.data };
        } catch (err: any) {
          return { data: null, error: { message: err?.message || String(err) } };
        }
      },
      createSignedUrl: async (path: string, opts?: any) => {
        try {
          const params = new URLSearchParams({ bucket, path });
          if (opts?.expires) params.set('expires', String(opts.expires));
          const res = await fetch(`${API_URL}/storage/signedUrl?${params.toString()}`);
          const json = await res.json();
          return { data: json.data };
        } catch (err: any) {
          return { data: null, error: { message: err?.message || String(err) } };
        }
      }
    })
  },
  channel: (name: string) => {
    const socket = getSocket();
    const listeners: Array<{ eventName: string, handler: (...args: any[]) => void }> = [];
    const ch = {
      name,
      on: (_eventType: string, opts: any, handler: (...args: any[]) => void) => {
        // support Supabase 'postgres_changes' event shape: { event, schema, table }
        if (_eventType === 'postgres_changes' && opts && opts.table) {
          const events = opts.event === '*' ? ['INSERT', 'UPDATE', 'DELETE'] : [opts.event];
          events.forEach((evt: string) => {
            const eventName = `${opts.table}:${evt}`;
            const fn = (...args: any[]) => handler(...args);
            listeners.push({ eventName, handler: fn });
            try { socket?.on(eventName, fn); } catch (e) { }
          });
        }
        return ch;
      },
      subscribe: async () => ({ status: 'SUBSCRIBED' }),
      unsubscribe: () => {
        listeners.forEach(({ eventName, handler }) => {
          try { socket?.off(eventName, handler); } catch (e) { }
        });
        listeners.length = 0;
      }
    } as any;
    return ch;
  },
  removeChannel: (ch: any) => { try { ch?.unsubscribe?.(); } catch (e) { } },
  rpc: async (path: string, body?: any) => {
    const token = localStorage.getItem('auth_token');
    const res = await fetch(`${API_URL}/${path}`, { method: body ? 'POST' : 'GET', headers: { 'Content-Type': 'application/json', ...(token ? { Authorization: `Bearer ${token}` } : {}) }, body: body ? JSON.stringify(body) : undefined });
    return res.json();
  }
} as any;